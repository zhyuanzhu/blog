# 正则表达式字符匹配攻略

正则表达式是匹配模式，要么`匹配字符串`，要么`匹配位置`

## 1 两种模糊匹配

- 1.1 横向模糊匹配

  - `横向模糊匹配`指的是一个正则匹配的字符串的长度不是固定的，可以是多种情况的

  - 实现方式：使用量词。譬如 `{m, n}` 表示连续出现最少 `m` 次，最多 `n` 次
  ```js
    const reg = /ab{2,5}c/      
    // 匹配字符串，第一个字符串是 "a"，接下来是 2 - 5个 "b"，最后是一个 "c"

    const reg1 = /ab{2,5}c/g
    // g 全局匹配，而不是匹配第一个

    var str = 'abc abbc abbbc abbbbc abbbbbc abbbbbbc'
    console.log(str.match(reg))
    // [ 'abbc', 'abbbc', 'abbbbc', 'abbbbbc' ]
  ```

- 1.2 纵向模糊匹配

  - `纵向模糊匹配`指的是一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能

  - 实现方式：字符组。譬如 `[abc]`，表示该字符可以是 `"a", "b", "c"` 中的任何一个
  ```js
    const reg = /a[123]b/
    // 可以匹配 a1b a2b a3b
    const reg2 = /a[123]b/g
    const str2 = 'a0b a1b a2b a3b a4b'
    console.log(str2.match(reg2))
    // [ 'a1b', 'a2b', 'a3b' ]

  ```

## 2 字符组

> 虽然叫`字符组`，但匹配的只是其中一个`字符`
```js
  const ret = /[abc]/
  // 匹配一个字符，可以是 `"a", "b", "c"` 之一
```

- 2.1 范围表示法

  - 使用连字符 `-` 来省略和简写
  ```js
    let reg = /[123456789abcdefgHIGKLMN]/ 
    // 等价于
    reg = /[1-9z-fH-N]/
    // 需要匹配 "a" "-" "b"这三者之一 。则转意符 - 需要放置在【开头】、【结尾】或者【使用转意符】
    reg = /ab-/
    reg = /-ab/
    reg = /a\-b/
  ```

- 2.2 排除字符组

  - 使用脱字符 `^` ：表示求反的意思

  - 纵向模糊匹配有种情况就是匹配除了某个或某几个字符之外可以是其他任何东西。可以使用 `排除` 字符组（`反义字符组`）
  ```js
    const reg = /[^abc]/
    // 匹配除了 "a" "b" "c" 之外的任意一个字符

  ```

- 2.3 常见的简写形式

|  字符组  |  具体含义  |
| :-----: | :------- |
| \d      | 表示 [0-9]。表示是`一位数字` |
| \D      | 表示 [^0-9]。表示`除数字之外` 的 `任意字符` |
| \w      | 表示 [0-9a-zA-Z_]。表示 `数字`、`大小写字母` 和 `下划线`；也称**单词字符** |
| \W      | 表示 [^0-9a-zA-Z_]。表示 **非单词字符** |
| \s      | 表示 [ \t\v\r\f]。 表示 **空白字符**，包括 `空格`、`水平制表符`、`垂直制表符`、`换行符`、`回车符`、`换页符` |
| \S      | 表示 [^ \t\v\r\f]。表示 **非空白字符** |
| .       | 表示 [^\n\r\u2089\u2029]。**通配符**，表示`几乎任意字符`。`换行符`、`回车符`、`行分隔符`和`段分隔符`除外 |
|

```js
  let reg = /[^]/
      reg = /[\d\D]/
      reg = /[\w\W]/
      reg = /[\s\S]/
  // 匹配任意字符

  // 问题
  // 如何匹配一个空字符串 ''
  const emptyStr = /[^]{0}/

```

## 3 量词

- 3.1 简写形式

| 量词 | 具体含义 |
| ---- | ------- |
| {m,} | 表示**至少出现** `m` 次 |
| {m}  | 等价于 {m,m}，表示出现 `m` 次 |
| ?    | 等价于 {0,1}，表示出现或者不出现 |
| +    | 等价于 {1,}，表示出现至少一次 |
| *    | 等价于 {0,}，表示出现任意次，有可能不出现 |
|

- 3.2 贪婪匹配与惰性匹配

  - `贪婪匹配`：会尽可能多的匹配 **匹配满足条件的最大长度**

  - `惰性匹配`：会尽可能少的匹配
  ```js
    // 惰性匹配  2 - 5 次都行，但2个就够的时候就不再往下尝试了，不去尝试 3 4 5 个
    const reg = /\d{2,5}?/g

    // 贪婪匹配 会尽可能多的匹配 3 4 5，6个的时候匹配5个
    // 数字是3位的时候就去匹配3位，4位 匹配 4位，5位 匹配 5位，给了6就拿最大的5去匹配
    const reg1 = /\d{2,5}/g
    const str = '123 1234 12345 123456'
    console.log(str.match(reg))
    // ['12', '12', '34','12', '34', '12','34', '56']
    console.log(str.match(reg1))
    // [ '123', '1234', '12345', '12345' ]

  ```

  | 惰性量词 | 贪婪量词 |
  | ------- | ------- |
  | {m,n}?  | {m,n}   |
  | {m,}?   | {m,}    |
  | ??      | ?       |
  | +?      | +       |
  | *?      | *       |

## 4 多选分支

- 4.1 使用 `（管道符）`  `|` 分割，表示其中任何之一

- 4.2 分支结构是惰性的，即当前匹配到了就不会再往后面找了
```js
  const reg = /good|goodbye/
  const str = 'goodbye'
  console.log(str.match(reg))
  // good
  const reg2 = /goodbye|good/
  console.log(str.match(reg2))
  // goodbye
```


# 缓存

## 命中和未命中

> `缓存再验证`：缓存对缓存对副本进行再验证时，会向服务器发送一个小对再验证请求。如果内容没有变化，服务器会返回 `304 Not Modifyied` 进行响应。只要缓存知道副本仍然有效，就会再次将副本标识为暂时新鲜的，并将副本提供给客户端。这被称为 `再验证命中` 或 `缓慢命中`

- 请求示例

  - 命中缓存，直接返回缓存数据

  - 未命中缓存，查看缓存是否新鲜，缓存和服务器资源比对

    - 缓存新鲜，返回缓存数据

    - 缓存过期了，返回服务器信息，同时更新缓存中的数据

![image text](./images/cache.drawio.svg)

## 缓存的处理步骤

- 接收： 缓存从网络中读取抵达的请求报文

- 解析：缓存对报文进行解析，提取出 URL 和各种首部

  - 将请求报文解析为片断，将首部的各个部分放于易于操作的数据结构中。 `便于缓存软件更容易处理首部字段`

- 查询：缓存查看是否有本地副本可用，如果没有，就读取一份（并将其保存在本地）

  - 查看缓存中是否有副本，如果没就去原始服务器或父级代理中去取，或返回一条错误信息

  - 已缓存对象包含了服务器响应主体和原始服务器响应首部，这样就会在 `缓存命中` 时返回正确的服务器首部。

- 新鲜度检测：缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新

- 创建响应：缓存会用新的首部和已缓存的主体来构建一条响应报文

- 日志：缓存可选地创建一个日志文件来描述这个事务

## 保持缓存副本的新鲜

- 文档过期：`Cache-Control` 和 `Expires`

- 过期日期和使用期

  - `Cache-Control` 首部：http 1.1 `max-age=xxx`

    - `max-age` 定义了文档的最大使用期：最大的合法生存时间，第一次创建到不再新鲜，以秒为单位

  - `Expires` 首部：http 1.0 指定一个绝对的过期日期

    - 一个绝对日期，如果日期已经过了，就说明文档不再新鲜了

- 服务器再验证

  - 内容发生了变化：缓存获取一份新的，并将其存储在旧位置，将文档发送给客户端

  - 内容未变化：缓存获取新的首部，包括一个新的过期日期，更新缓存中的首部

- 用条件方法再验证

  - `If-Modified-Since:<date>`：Date 再验证

    - 如果从指定日期之后文档被修改过了，`If-Modified-Since` 就为真。执行请求方法，携带新首部的文档会被返回给缓存

    - 如果没被修改，会向客户端返回 `304 Not Modified` 报文呢

  - `If-None-Match:<tags>`：实体标签再验证

    - 存在的问题

      - 有些文档经常被写入，但实际包含但数据一致。内容未变化，修改日期发生了变化

      - 文档被修改了，修改不重要；例如修改了注释

      - 文档修改变化间隙太小，以秒为粒度的修改日期不够用

      - 有些服务器无法准确判定其页面的最后修改日期

    - 解决方案

      - 与 `实体标签（Etag）`的 `“版本标识符”` 进行比较

        - 实体标签是附加到文档上的任意标签，可能包含了文档的序列号或版本名，或者是文档内容的校验以及其他指纹信息

    - 将 `If-None-Match` 首部需要检查的实体标签找到，与服务器中的进行比较。如果标签不再匹配，就会返回一个新对象。如果匹配，则会返回一条 `304 Not Modified`

## 控制缓存的能力

> **控制缓存能力优先级**： `Cache-Control: no-store` - `Cache-Control: no-cache` - `Cache-Control: must-revalidate` - `Cache-Control: max-age` - `Expires` - `不附加过期信息`：控制缓存能力递减

- `no-store`：禁止对响应进行复制，缓存会像非缓存代理服务器一样，向客户端转发，然后删除对象

- `no-cache`：可以存储在本地缓存区中。**在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用**

- `max-age=xxx`：文档处于新鲜状态的秒数

- `Expires`：实际的过期日期

- `试探性过期`：如果缓存中没有 `Cache-Control: max-age=xxx` 和 `Expires` 首部，缓存可以计算出一个试探性的最大使用期



